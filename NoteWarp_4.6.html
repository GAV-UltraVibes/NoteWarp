<!DOCTYPE html>
<!--
NoteWarp — редактор для быстрого набора шаблонных небольших текстов с автозаменой сокращений.

Сильные стороны:
• Полностью локальное исполнение (без серверов и интернета)
• Единый файл (self-contained HTML+JS)
• Экспорт/импорт словарей и настроек
• Не требует прав администратора
• Кроссплатформенность (работает в любом современном браузере)
• Минималистичный интерфейс с фокусом на скорость набора
• Поддержка именованных маркеров для навигации и шаблонизации

Copyright (c) 2024-2026 Александр Гаркавцев, Qwen, Алиса

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<html>
<head>
<title>NoteWarp - редактор с автозаменами</title>
<style>
body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 20px;
  max-width: 80%;
  margin: 0 auto;
}

/* Заголовок приложения */
.app-header {
  text-align: center;
  margin-bottom: 20px;
}
.app-title {
  font-family: 'Arial Rounded MT Bold', 'Helvetica Neue', sans-serif;
  font-weight: normal;
  font-size: 2.8em;
  background: linear-gradient(45deg, #007cba, #00cc66);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin: 10px 0;
  letter-spacing: -0.5px;
  text-align: center;
}

/* Вкладки и кнопки навигации */
.tabs {
  margin-bottom: 20px;
  display: flex;
  justify-content: space-between;
}
.tab-buttons-container {
  display: flex;
}
.tab-button {
  padding: 10px 20px;
  background-color: #f0f0f0;
  border: 1px solid #ccc;
  cursor: pointer;
  margin-right: 5px;
}
.tab-button.active {
  background-color: #007cba;
  color: white;
}
.help-button {
  padding: 10px 20px;
  background-color: #6c757d;
  color: white;
  border: 1px solid #ccc;
  cursor: pointer;
  margin-left: 5px;
}
.help-button:hover {
  background-color: #5a6268;
}

/* Видимость вкладок */
#editor-tab, #dictionary-tab {
  display: none;
}
#editor-tab.active, #dictionary-tab.active {
  display: block;
}

/* Основное поле редактора */
#editor {
  width: 100%;
  height: 60vh;
  border: 1px solid #ccc;
  padding: 10px;
  font-family: 'Courier New', monospace;
  font-size: 14px;
  line-height: 1.4;
  outline: none;
  background-color: white;
  box-sizing: border-box;
}
#editor:focus {
  border-color: #007cba;
}

/* Панель сохранения файла */
.save-panel {
  margin-top: 10px;
  padding: 10px;
  background-color: #f8f9fa;
  border-radius: 5px;
  border: 1px solid #e9ecef;
}
.save-controls {
  display: flex;
  gap: 10px;
  align-items: center;
}
.filename-input {
  flex: 1;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 3px;
  font-family: 'Courier New', monospace;
}
.save-button {
  padding: 8px 15px;
  background-color: #28a745;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
}
.save-button:hover {
  background-color: #218838;
}
.save-button:disabled {
  background-color: #ccc;
  cursor: not-allowed;
}
.filename-error {
  color: #dc3545;
  font-size: 12px;
  margin-top: 5px;
  display: none;
}

/* Макет панели управления словарями */
.dictionary-manager {
  display: block;
}
.shortcuts-list {
  width: 48%;
  float: left;
  border: transparent;
  padding: 10px;
  box-sizing: border-box;
}
.replacement-editor {
  width: 48%;
  float: right;
  padding: 10px;
  box-sizing: border-box;
}

/* Панели управления словарями */
.dictionary-panel {
  margin-bottom: 15px;
  padding: 10px;
  background-color: #f8f9fa;
  border-radius: 5px;
  border: 1px solid #e9ecef;
}
.dictionary-panel h3 {
  margin-top: 0;
  color: #007cba;
}
.editing-dict-panel {
  margin-bottom: 15px;
  padding: 10px;
  background-color: #e9ecef;
  border-radius: 5px;
  border: 1px solid #ced4da;
}
.editing-dict-panel h3 {
  margin-top: 0;
  color: #495057;
}
.editing-substitution-panel {
  padding: 10px;
  background-color: #f8f9fa;
  border-radius: 5px;
  border: 1px solid #e9ecef;
}
.editing-substitution-panel h3 {
  margin-top: 0;
  color: #007cba;
}

/* Зона перетаскивания файлов словарей */
.drop-zone {
  border: 2px dashed #ccc;
  border-radius: 5px;
  padding: 15px;
  text-align: center;
  margin-bottom: 10px;
  background-color: #f9f9f9;
  transition: all 0.3s;
}
.drop-zone.dragover {
  border-color: #007cba;
  background-color: #e3f2fd;
}

/* Кнопки управления словарями */
.dictionary-buttons {
  display: block;
}
.dictionary-buttons button {
  padding: 8px 15px;
  background-color: #17a2b8;
  color: white;
  border: none;
  cursor: pointer;
  border-radius: 3px;
  margin-right: 5px;
  margin-bottom: 5px;
}
.dictionary-buttons button:hover {
  background-color: #138496;
}

/* Таблица сокращений */
.shortcut-table-container {
  max-height: 35vh;
  overflow-y: auto;
  margin-bottom: 5px;
}
.current-dict-name {
  font-weight: bold;
  margin-bottom: 5px;
  padding: 2px 5px;
  background-color: #f0f0f0;
  border-radius: 3px;
}
.shortcut-table {
  width: 100%;
  border-collapse: collapse;
}
.shortcut-table th, .shortcut-table td {
  border: 1px solid #ddd;
  padding: 4px;
  text-align: left;
}
.shortcut-table th {
  background-color: #f2f2f2;
}
.shortcut-table tr:hover {
  background-color: #f5f5f5;
  cursor: pointer;
}
.shortcut-table tr.selected {
  background-color: #007cba;
  color: white;
}
.shortcut-table tr.conflicting-shortcut-row {
  color: #dc3545;
  font-weight: bold;
  background-color: #ffeef0;
}

/* Поля редактирования сокращений */
.shortcut-edit-field {
  margin-bottom: 10px;
}
.shortcut-edit-field label {
  display: block;
  margin-bottom: 5px;
  font-weight: bold;
}
.shortcut-edit-field input {
  width: 100%;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 3px;
  font-family: 'Courier New', monospace;
  box-sizing: border-box;
}
.replacement-edit-field {
  display: block;
  margin-bottom: 10px;
}
.replacement-edit-field label {
  display: block;
  margin-bottom: 5px;
  font-weight: bold;
}
.replacement-edit-field textarea {
  width: 100%;
  font-family: 'Courier New', monospace;
  font-size: 14px;
  padding: 10px;
  border: 1px solid #ccc;
  box-sizing: border-box;
  border-radius: 3px;
  height: 60vh;
  resize: none;
}

/* Кнопки редактирования подстановок */
.editor-buttons {
  display: block;
  text-align: right;
}
.editor-buttons button {
  padding: 8px 15px;
  border: none;
  cursor: pointer;
  border-radius: 3px;
  margin-left: 5px;
}
.editor-buttons button.save {
  background-color: #28a745;
  color: white;
}
.editor-buttons button.save:hover {
  background-color: #218838;
}
.editor-buttons button.delete {
  background-color: #dc3545;
  color: white;
}
.editor-buttons button.delete:hover {
  background-color: #c82333;
}
.editor-buttons button:disabled {
  background-color: #ccc;
  cursor: not-allowed;
}
.error-message {
  color: #dc3545;
  font-size: 12px;
  margin-top: 5px;
  display: none;
}

/* Таблица списка словарей */
.dictionaries-list-container {
  margin-top: 15px;
}
.dictionaries-table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 5px;
}
.dictionaries-table th, .dictionaries-table td {
  border: 1px solid #ddd;
  padding: 5px;
  text-align: left;
}
.dictionaries-table th {
  background-color: #f2f2f2;
}
.dictionaries-table .toggle-cell {
  width: 1%;
  white-space: nowrap;
}
.dictionaries-table .name-cell {
  width: auto;
}
.dictionaries-table .actions-cell {
  width: 1%;
  white-space: nowrap;
}

/* Индикатор конфликтов сокращений */
.conflict-status {
  margin-top: 10px;
  padding: 5px;
  background-color: #fff3cd;
  border: 1px solid #ffeaa7;
  color: #856404;
  border-radius: 3px;
  font-size: 12px;
  display: none;
}

/* Модальные окна */
.popup-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}
.popup-content {
  background: white;
  padding: 20px;
  border-radius: 5px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.3);
  width: 600px;
  max-height: 80vh;
  overflow-y: auto;
}
.popup-content input {
  width: 100%;
  padding: 8px;
  margin-top: 10px;
  margin-bottom: 15px;
  box-sizing: border-box;
}
.popup-content button {
  padding: 8px 15px;
  margin-right: 10px;
}

/* Стили справки */
.help-content h3 {
  color: #007cba;
  border-bottom: 1px solid #ccc;
  padding-bottom: 5px;
}
.help-content p, .help-content ul {
  margin: 8px 0;
}
.help-content ul {
  padding-left: 20px;
}
.help-content li {
  margin-bottom: 5px;
}
.help-content code {
  background-color: #f0f0f0;
  padding: 2px 4px;
  border-radius: 3px;
  font-family: 'Courier New', monospace;
}

/* Панель настроек обратной связи (звук, визуал, перенос) */
.feedback-panel {
  margin-top: 10px;
  padding: 10px;
  background-color: #f8f9fa;
  border-radius: 5px;
  border: 1px solid #e9ecef;
}
.feedback-controls {
  display: flex;
  gap: 15px;
  align-items: center;
  flex-wrap: nowrap;
}
.feedback-option {
  display: flex;
  align-items: center;
  gap: 5px;
  white-space: nowrap;
}
.feedback-option input {
  margin: 0;
}
</style>
</head>
<body>
<div class="app-header">
  <div class="app-title" id="animated-title">NoteWarp</div>
</div>
<div class="tabs">
  <div class="tab-buttons-container">
    <button class="tab-button active" data-tab="editor-tab">Редактор</button>
    <button class="tab-button" data-tab="dictionary-tab">Словарь</button>
  </div>
  <button class="help-button" id="help-button">[?]</button>
</div>

<!-- Вкладка редактора -->
<div id="editor-tab" class="active">
  <textarea id="editor" style="width:100%; height:400px; font-family: 'Courier New', monospace; font-size: 14px;"></textarea>
  
  <!-- Панель настроек обратной связи и переноса -->
  <div class="feedback-panel">
    <div class="feedback-controls">
      <div class="feedback-option">
        <input type="checkbox" id="word-wrap-checkbox">
        <label for="word-wrap-checkbox">Перенос по словам</label>
      </div>
      <div class="feedback-option">
        <input type="checkbox" id="feedback-sound-checkbox">
        <label for="feedback-sound-checkbox">Звук</label>
      </div>
      <div class="feedback-option">
        <input type="checkbox" id="feedback-visual-checkbox">
        <label for="feedback-visual-checkbox">Мигание</label>
      </div>
    </div>
  </div>
  
  <!-- Панель сохранения файла -->
  <div class="save-panel">
    <div class="save-controls">
      <input type="text" class="filename-input" id="filename-input" placeholder="Введите имя файла (без расширения)">
      <button class="save-button" id="save-file-btn">Сохранить</button>
    </div>
    <div class="filename-error" id="filename-error"></div>
  </div>
</div>

<!-- Вкладка управления словарями -->
<div id="dictionary-tab">
  <div class="dictionary-manager">
    <div class="shortcuts-list">
      <div class="dictionary-panel">
        <h3>Управление словарями</h3>
        <div class="dictionaries-list-container">
          <table class="dictionaries-table">
            <thead>
              <tr>
                <th>Вкл</th>
                <th>Имя файла</th>
                <th>Действия</th>
              </tr>
            </thead>
            <tbody id="dictionaries-table-body">
            </tbody>
          </table>
          <div id="conflict-status" class="conflict-status"></div>
        </div>
        
        <!-- Зона перетаскивания для импорта словарей -->
        <div class="drop-zone" id="drop-zone">
          Перетащите файл словаря (TXT) сюда
        </div>
      </div>
      
      <!-- Таблица сокращений текущего словаря -->
      <div class="editing-dict-panel">
        <h3 id="editing-dict-title">Редактирование словаря</h3>
        <div class="shortcut-table-container">
          <table class="shortcut-table">
            <thead>
              <tr>
                <th>Сокращение</th>
                <th>Подстановка</th>
              </tr>
            </thead>
            <tbody id="shortcuts-table-body">
            </tbody>
          </table>
        </div>
      </div>
    </div>
    
    <!-- Панель редактирования выбранного сокращения -->
    <div class="replacement-editor">
      <div class="editing-substitution-panel">
        <div class="shortcut-edit-field">
          <label for="edit-shortcut">Сокращение:</label>
          <input type="text" id="edit-shortcut" placeholder="Введите сокращение">
          <div class="error-message" id="shortcut-error"></div>
        </div>
        <div class="replacement-edit-field">
          <label for="edit-replacement">Подстановка:</label>
          <textarea id="edit-replacement" placeholder="Введите текст подстановки"></textarea>
        </div>
        <div class="editor-buttons">
          <button id="delete-shortcut-btn" class="delete" disabled>Удалить</button>
          <button id="save-shortcut-btn" class="save">Сохранить</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
// ============================================================================
// Основные классы приложения NoteWarp
// ============================================================================

/**
 * Утилиты для работы с DOM
 */
class DOMUtils {
  /**
   * Отображение сообщения об ошибке
   */
  static showError(element, message) {
    element.textContent = message;
    element.style.display = 'block';
  }

  /**
   * Скрытие сообщения об ошибке
   */
  static clearError(element) {
    element.style.display = 'none';
  }

  /**
   * Создание модального окна для ввода имени маркера
   */
  static createTagInputPopup(callback) {
    const overlay = document.createElement('div');
    overlay.className = 'popup-overlay';
    overlay.innerHTML = `
      <div class="popup-content">
        <h3>Введите имя маркера</h3>
        <input type="text" id="tag-input" placeholder="Имя маркера">
        <button id="popup-ok-btn">Ок</button>
        <button id="popup-cancel-btn">Отмена</button>
      </div>
    `;
    document.body.appendChild(overlay);

    const input = document.getElementById('tag-input');
    const okBtn = document.getElementById('popup-ok-btn');
    const cancelBtn = document.getElementById('popup-cancel-btn');

    // Обработка нажатия Enter в поле ввода
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        e.stopPropagation();
        const name = input.value.trim();
        if (name.includes(' ')) {
          alert('Имя маркера не должно содержать пробелы.');
          return;
        }
        if (name) {
          callback(name);
        }
        document.body.removeChild(overlay);
        document.getElementById('editor').focus();
      }
    });

    // Обработка кнопки Ок
    okBtn.addEventListener('click', () => {
      const name = input.value.trim();
      if (name.includes(' ')) {
        alert('Имя маркера не должно содержать пробелы.');
        return;
      }
      if (name) {
        callback(name);
      }
      document.body.removeChild(overlay);
      document.getElementById('editor').focus();
    });

    // Обработка кнопки Отмена
    cancelBtn.addEventListener('click', () => {
      document.body.removeChild(overlay);
      document.getElementById('editor').focus();
    });

    input.focus();
  }

  /**
   * Создание модального окна справки
   */
  static createHelpPopup(contentHTML, callback) {
    const overlay = document.createElement('div');
    overlay.className = 'popup-overlay';
    overlay.innerHTML = `
      <div class="popup-content">
        <div class="help-content">${contentHTML}</div>
        <button id="popup-close-btn">Закрыть</button>
      </div>
    `;
    document.body.appendChild(overlay);

    const closeBtn = document.getElementById('popup-close-btn');
    closeBtn.addEventListener('click', () => {
      document.body.removeChild(overlay);
      if (callback) callback();
    });
  }
}

/**
 * Менеджер обратной связи (звук и визуальные эффекты)
 */
class FeedbackManager {
  constructor() {
    this.soundEnabled = false;
    this.visualEnabled = false;
    this.audioContext = null;
    this.loadSettings();
    this.setupUI();
  }

  /**
   * Настройка элементов управления обратной связью
   */
  setupUI() {
    const soundCheckbox = document.getElementById('feedback-sound-checkbox');
    const visualCheckbox = document.getElementById('feedback-visual-checkbox');
    
    if (soundCheckbox && visualCheckbox) {
      soundCheckbox.checked = this.soundEnabled;
      visualCheckbox.checked = this.visualEnabled;
      
      soundCheckbox.addEventListener('change', (e) => {
        this.soundEnabled = e.target.checked;
        this.saveSettings();
      });
      
      visualCheckbox.addEventListener('change', (e) => {
        this.visualEnabled = e.target.checked;
        this.saveSettings();
      });
    }
  }

  /**
   * Загрузка настроек из localStorage
   */
  loadSettings() {
    const saved = localStorage.getItem('noteWarpFeedbackSettings');
    if (saved) {
      try {
        const settings = JSON.parse(saved);
        this.soundEnabled = settings.sound || false;
        this.visualEnabled = settings.visual || false;
      } catch (e) {
        console.warn('Could not load feedback settings, using defaults.');
      }
    }
  }

  /**
   * Сохранение настроек в localStorage
   */
  saveSettings() {
    const settings = {
      sound: this.soundEnabled,
      visual: this.visualEnabled
    };
    localStorage.setItem('noteWarpFeedbackSettings', JSON.stringify(settings));
  }

  /**
   * Инициализация аудиоконтекста Web Audio API
   */
  initAudio() {
    if (!this.audioContext) {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
  }

  /**
   * Воспроизведение короткого звукового сигнала
   */
  playSound() {
    this.initAudio();
    const ctx = this.audioContext;
    const now = ctx.currentTime;
    const duration = 0.12;
    
    const oscillator = ctx.createOscillator();
    const gain = ctx.createGain();
    
    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(180, now);
    oscillator.frequency.exponentialRampToValueAtTime(280, now + duration);
    
    gain.gain.setValueAtTime(0.01, now);
    gain.gain.linearRampToValueAtTime(0.08, now + duration);
    gain.gain.setValueAtTime(0.08, now + duration);
    gain.gain.exponentialRampToValueAtTime(0.001, now + duration + 0.02);
    
    oscillator.connect(gain);
    gain.connect(ctx.destination);
    
    oscillator.start(now);
    oscillator.stop(now + duration + 0.02);
  }

  /**
   * Визуальный эффект "мигания" фона
   */
  triggerWarp() {
    const body = document.body;
    const originalBg = getComputedStyle(body).backgroundColor || '#ffffff';
    body.style.backgroundColor = 'rgba(0, 0, 0, 0.04)';
    setTimeout(() => {
      body.style.backgroundColor = originalBg;
    }, 100);
  }

  /**
   * Триггер обратной связи (звук + визуал)
   */
  triggerFeedback() {
    if (this.soundEnabled) {
      this.playSound();
    }
    if (this.visualEnabled) {
      this.triggerWarp();
    }
  }
}

/**
 * Утилиты для манипуляции текстом
 */
class TextManipulator {
  /**
   * Вставка текста в текущую позицию курсора
   */
  static insertTextAtCursor(text, element) {
    const startPos = element.selectionStart;
    const endPos = element.selectionEnd;
    const before = element.value.substring(0, startPos);
    const after = element.value.substring(endPos);
    element.value = before + text + after;
    element.setSelectionRange(startPos + text.length, startPos + text.length);
  }
}

/**
 * Система автозамены сокращений
 */
class AutoReplacer {
  constructor(dictionaryManager, maxBufferSize = 50) {
    this.dictionaryManager = dictionaryManager;
    this.maxBufferSize = maxBufferSize;
  }

  /**
   * Обновление буфера ввода с ограничением размера
   */
  updateBuffer(buffer, text) {
    buffer += text;
    if (buffer.length > this.maxBufferSize) {
      buffer = buffer.slice(-this.maxBufferSize);
    }
    return buffer;
  }

  /**
   * Проверка буфера на наличие сокращений для замены
   */
  checkAndReplace(buffer, element, insertCallback) {
    const dictionary = this.dictionaryManager.getActiveDictionary();
    const sortedKeys = Object.keys(dictionary).sort((a, b) => b.length - a.length);
    
    for (let word of sortedKeys) {
      if (buffer.endsWith(word)) {
        const replacement = dictionary[word];
        insertCallback(word, replacement);
        return true;
      }
    }
    return false;
  }
}

/**
 * Менеджер истории изменений (отмена/повтор)
 */
class HistoryManager {
  constructor(maxSize = 100) {
    this.history = [];
    this.index = -1;
    this.maxSize = maxSize;
  }

  /**
   * Добавление состояния в историю
   */
  pushState(state) {
    if (this.index < this.history.length - 1) {
      this.history = this.history.slice(0, this.index + 1);
    }
    this.history.push(state);
    this.index++;
    if (this.history.length > this.maxSize) {
      this.history.shift();
      this.index--;
    }
  }

  /**
   * Отмена последнего действия
   */
  undo() {
    if (this.index > 0) {
      this.index--;
      return this.history[this.index];
    }
    return null;
  }

  /**
   * Повтор отменённого действия
   */
  redo() {
    if (this.index < this.history.length - 1) {
      this.index++;
      return this.history[this.index];
    }
    return null;
  }
}

/**
 * Основной класс текстового редактора
 */
class TextEditor {
  constructor(element, dictManager, feedbackManager) {
    this.editor = element;
    this.dictionaryManager = dictManager;
    this.feedbackManager = feedbackManager;
    this.lastSearchPositions = {};
    this.inputBuffer = "";
    this.isUndoRedoOperation = false;
    this.autoReplacer = new AutoReplacer(dictManager);
    this.historyManager = new HistoryManager(100);
    
    this.setupEventListeners();
    this.setupWordWrap();
    this.loadWordWrapSetting();
    this.setupSaveFunctionality();
    this.setInitialFilename();
    this.saveHistoryState();
  }

  /**
   * Загрузка настройки переноса слов из localStorage
   */
  loadWordWrapSetting() {
    const saved = localStorage.getItem('noteWarpWordWrap');
    if (saved !== null) {
      const enabled = saved === 'true';
      const checkbox = document.getElementById('word-wrap-checkbox');
      if (checkbox) {
        checkbox.checked = enabled;
        this.editor.wrap = enabled ? 'soft' : 'off';
      }
    }
  }

  /**
   * Настройка переключателя переноса слов
   */
  setupWordWrap() {
    const checkbox = document.getElementById('word-wrap-checkbox');
    checkbox.addEventListener('change', (e) => {
      if (e.target.checked) {
        this.editor.wrap = 'soft';
      } else {
        this.editor.wrap = 'off';
      }
      localStorage.setItem('noteWarpWordWrap', e.target.checked);
    });
  }

  /**
   * Настройка обработчиков событий клавиатуры и ввода
   */
  setupEventListeners() {
    this.editor.addEventListener('keydown', (e) => this.handleKeyDown(e));
    this.editor.addEventListener('input', (e) => this.handleInput(e));
    this.editor.addEventListener('paste', (e) => this.handlePaste(e));
  }

  /**
   * Настройка функционала сохранения файла
   */
  setupSaveFunctionality() {
    const saveBtn = document.getElementById('save-file-btn');
    const filenameInput = document.getElementById('filename-input');
    
    filenameInput.addEventListener('blur', () => {
      const currentFilename = filenameInput.value;
      const processedFilename = this.processFilenameTemplate(currentFilename);
      if (processedFilename !== currentFilename) {
        filenameInput.value = processedFilename;
      }
    });
    
    saveBtn.addEventListener('click', () => this.saveFile());
    filenameInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') this.saveFile();
    });
  }

  /**
   * Установка начального имени файла (текущая дата и время)
   */
  setInitialFilename() {
    const now = new Date();
    const isoDate = now.toISOString().split('T')[0];
    const time = now.toTimeString().split(' ')[0].substring(0, 5).replace(':', '-');
    const defaultFilename = isoDate + ' ' + time;
    document.getElementById('filename-input').value = defaultFilename;
  }

  /**
   * Сохранение содержимого редактора в файл
   */
  saveFile() {
    let filename = document.getElementById('filename-input').value.trim();
    const errorElement = document.getElementById('filename-error');
    
    filename = this.processFilenameTemplate(filename);
    
    if (!filename) {
      DOMUtils.showError(errorElement, 'Имя файла не может быть пустым');
      return;
    }
    
    const invalidChars = /[<>:"/\\|?*\x00-\x1F]/;
    if (invalidChars.test(filename)) {
      DOMUtils.showError(errorElement, 'Недопустимые символы');
      return;
    }
    
    if (filename.length > 255) {
      DOMUtils.showError(errorElement, 'Имя файла слишком длинное');
      return;
    }
    
    DOMUtils.clearError(errorElement);
    const content = this.editor.value;
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename + '.txt';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  /**
   * Сохранение состояния в историю изменений
   */
  saveHistoryState() {
    const content = this.editor.value;
    const cursorPos = this.getCursorPosition();
    this.historyManager.pushState({ content, cursorPos });
  }

  /**
   * Отмена последнего действия
   */
  undo() {
    const state = this.historyManager.undo();
    if (state) {
      this.isUndoRedoOperation = true;
      this.editor.value = state.content;
      this.setCursorPosition(state.cursorPos);
      setTimeout(() => this.isUndoRedoOperation = false, 0);
    }
  }

  /**
   * Повтор отменённого действия
   */
  redo() {
    const state = this.historyManager.redo();
    if (state) {
      this.isUndoRedoOperation = true;
      this.editor.value = state.content;
      this.setCursorPosition(state.cursorPos);
      setTimeout(() => this.isUndoRedoOperation = false, 0);
    }
  }

  /**
   * Получение текущей позиции курсора
   */
  getCursorPosition() {
    return this.editor.selectionStart;
  }

  /**
   * Установка позиции курсора
   */
  setCursorPosition(position) {
    this.editor.setSelectionRange(position, position);
  }

  /**
   * Выделение текста между позициями
   */
  selectText(start, end) {
    this.editor.setSelectionRange(start, end);
  }

  /**
   * Обработка нажатий клавиш
   */
  handleKeyDown(e) {
    // Навигация по маркерам: Ctrl+цифра / Ctrl+* / Ctrl+Alt+цифра / Ctrl+Alt+*
    if (e.ctrlKey) {
      const isDigit = e.key >= '0' && e.key <= '9';
      const isStar = e.key === '*';
      
      if (isDigit || isStar) {
        e.preventDefault();
        
        if (e.altKey) {
          // Ctrl+Alt+цифра — выделение между маркерами
          if (isDigit) {
            if (e.key === '0') return;
            this.navigateToTag(e.key, true);
          } else {
            TextEditor.currentAction = 'select';
            DOMUtils.createTagInputPopup((name) => {
              this.navigateToNamedTag(name, true);
            });
          }
        } else {
          // Ctrl+цифра — переход к закрывающему маркеру
          if (isDigit) {
            if (e.key === '0') {
              this.removeAllMarkers();
              return;
            }
            this.navigateToTag(e.key, false);
          } else {
            TextEditor.currentAction = 'move';
            DOMUtils.createTagInputPopup((name) => {
              this.navigateToNamedTag(name, false);
            });
          }
        }
        return;
      }
    }
    
    // Отмена/повтор (поддержка русской раскладки)
    if (e.ctrlKey && (e.key === 'z' || e.key === 'я')) {
      e.preventDefault();
      if (e.shiftKey) this.redo(); else this.undo();
      return;
    }
    
    if (e.ctrlKey && (e.key === 'y' || e.key === 'н')) {
      e.preventDefault();
      this.redo();
      return;
    }
    
    // Вставка табуляции
    if (e.key === 'Tab') {
      e.preventDefault();
      this.insertText('\t');
      return;
    }
    
    // Поиск следующего символа *
    if (e.altKey && (e.key === 'x' || e.key === 'ч')) {
      e.preventDefault();
      this.findAndSelectNext('*', 'star');
      return;
    }
    
    // Смена раскладки выделенного текста
    if (e.key === 'Pause') {
      e.preventDefault();
      this.toggleCyrillicSelection();
      return;
    }
    
    // Сохранение состояния перед удалением
    if (e.key === 'Backspace' || e.key === 'Delete') {
      if (!this.isUndoRedoOperation) this.saveHistoryState();
    }
  }

  /**
   * Обработка ввода текста (автозамена)
   */
  handleInput(e) {
    if (this.isUndoRedoOperation) return;
    
    const text = e.data || '';
    if (text) {
      this.inputBuffer = this.autoReplacer.updateBuffer(this.inputBuffer, text);
      
      if (!this.autoReplacer.checkAndReplace(this.inputBuffer, this.editor, (word, replacement) => {
        this.performAutoReplace(word, replacement);
      })) {
        setTimeout(() => this.saveHistoryState(), 0);
      }
    } else {
      setTimeout(() => this.saveHistoryState(), 0);
    }
  }

  /**
   * Обработка вставки текста
   */
  handlePaste() {
    if (!this.isUndoRedoOperation) setTimeout(() => this.saveHistoryState(), 0);
  }

  /**
   * Выполнение автозамены сокращения на подстановку
   */
  performAutoReplace(word, replacement) {
    this.saveHistoryState();
    const startPos = this.editor.selectionStart;
    const endPos = this.editor.selectionEnd;
    const startOfWord = Math.max(0, startPos - word.length);
    const textBefore = this.editor.value.substring(0, startOfWord);
    const textAfter = this.editor.value.substring(endPos);
    
    // Поддержка метки [курсор] для позиционирования курсора после замены
    const cursorMarkPos = replacement.indexOf('[курсор]');
    let cleanReplacement = replacement;
    let newCursorPos = startOfWord + replacement.length;
    
    if (cursorMarkPos !== -1) {
      cleanReplacement = replacement.replace('[курсор]', '');
      newCursorPos = startOfWord + cursorMarkPos;
    }
    
    this.editor.value = textBefore + cleanReplacement + textAfter;
    this.editor.setSelectionRange(newCursorPos, newCursorPos);
    this.inputBuffer = "";
    
    // Триггер обратной связи при успешной замене
    this.feedbackManager.triggerFeedback();
  }

  /**
   * Вставка текста в текущую позицию курсора
   */
  insertText(text) {
    if (!this.isUndoRedoOperation) this.saveHistoryState();
    const startPos = this.getCursorPosition();
    const before = this.editor.value.substring(0, startPos);
    const after = this.editor.value.substring(startPos);
    this.editor.value = before + text + after;
    this.setCursorPosition(startPos + text.length);
    this.inputBuffer = this.autoReplacer.updateBuffer(this.inputBuffer, text);
  }

  /**
   * Поиск и выделение следующего вхождения символа
   */
  findAndSelectNext(char, searchKey) {
    const content = this.editor.value;
    const cursorPos = this.getCursorPosition();
    let nextPos = content.indexOf(char, cursorPos + 1);
    
    if (nextPos === -1) nextPos = content.indexOf(char, 0);
    
    if (nextPos !== -1) {
      this.selectText(nextPos, nextPos + 1);
      this.lastSearchPositions[searchKey] = nextPos;
      this.feedbackManager.triggerFeedback();
    }
  }

  /**
   * Навигация к паре маркеров по цифровому идентификатору
   */
  navigateToTag(tag, shouldSelect = false) {
    const positions = this.findTagPairPositions(tag);
    if (positions) {
      const { openingEnd, closingStart } = positions;
      if (shouldSelect) {
        this.selectText(openingEnd, closingStart);
      } else {
        this.setCursorPosition(closingStart);
      }
      this.feedbackManager.triggerFeedback();
    }
  }

  /**
   * Навигация к паре маркеров по именованному идентификатору
   */
  navigateToNamedTag(tagName, shouldSelect = false) {
    const positions = this.findTagPairPositions(tagName);
    if (positions) {
      const { openingEnd, closingStart } = positions;
      if (shouldSelect) {
        this.selectText(openingEnd, closingStart);
      } else {
        this.setCursorPosition(closingStart);
      }
      this.feedbackManager.triggerFeedback();
    }
  }

  /**
   * Поиск позиций парных маркеров [имя> и <имя]
   */
  findTagPairPositions(tagName) {
    if (tagName.includes(' ')) {
      console.log('Имя маркера содержит пробелы, поиск пары отменён');
      return null;
    }
    
    const content = this.editor.value;
    const cursorPos = this.getCursorPosition();
    const escapedTagName = this.escapeRegExp(tagName);
    
    const openingRegex = new RegExp(`\\[${escapedTagName}>`, 'g');
    const closingRegex = new RegExp(`<${escapedTagName}\\]`, 'g');
    
    // Сбор всех вхождений открывающих и закрывающих маркеров
    let openingMatches = [];
    let closingMatches = [];
    let match;
    
    openingRegex.lastIndex = 0;
    while ((match = openingRegex.exec(content)) !== null) {
      openingMatches.push({ start: match.index, end: match.index + match[0].length });
    }
    
    closingRegex.lastIndex = 0;
    while ((match = closingRegex.exec(content)) !== null) {
      closingMatches.push({ start: match.index, end: match.index + match[0].length });
    }
    
    // Формирование пар маркеров
    let pairs = [];
    let closingIndex = 0;
    for (let opening of openingMatches) {
      while (closingIndex < closingMatches.length && closingMatches[closingIndex].start < opening.end) {
        closingIndex++;
      }
      if (closingIndex < closingMatches.length) {
        pairs.push({
          openingStart: opening.start,
          openingEnd: opening.end,
          closingStart: closingMatches[closingIndex].start,
          closingEnd: closingMatches[closingIndex].end
        });
        closingIndex++;
      }
    }
    
    pairs.sort((a, b) => a.openingStart - b.openingStart);
    if (pairs.length === 0) return null;
    
    // Поиск ближайшей пары относительно текущей позиции курсора
    let foundPair = null;
    for (let pair of pairs) {
      if (cursorPos >= pair.openingEnd && cursorPos <= pair.closingStart) {
        const currentIndex = pairs.indexOf(pair);
        const nextIndex = (currentIndex + 1) % pairs.length;
        foundPair = pairs[nextIndex];
        break;
      } else if (cursorPos < pair.openingStart) {
        foundPair = pair;
        break;
      }
    }
    
    if (!foundPair && pairs.length > 0) {
      const lastPair = pairs[pairs.length - 1];
      if (cursorPos > lastPair.closingEnd) {
        foundPair = pairs[0];
      }
    }
    
    return foundPair;
  }

  /**
   * Извлечение текста между парными маркерами для шаблонизации имени файла
   */
  extractTextBetweenMarkers(tagName) {
    if (tagName.includes(' ')) {
      console.log('Имя маркера содержит пробелы, извлечение отменено');
      return null;
    }
    
    const content = this.editor.value;
    const escapedTagName = this.escapeRegExp(tagName);
    const openingRegex = new RegExp(`\\[${escapedTagName}>`, 'g');
    const closingRegex = new RegExp(`<${escapedTagName}\\]`, 'g');
    
    let openingMatches = [];
    let closingMatches = [];
    let match;
    
    openingRegex.lastIndex = 0;
    while ((match = openingRegex.exec(content)) !== null) {
      openingMatches.push({ start: match.index, end: match.index + match[0].length });
    }
    
    closingRegex.lastIndex = 0;
    while ((match = closingRegex.exec(content)) !== null) {
      closingMatches.push({ start: match.index, end: match.index + match[0].length });
    }
    
    let pairs = [];
    let closingIndex = 0;
    for (let opening of openingMatches) {
      while (closingIndex < closingMatches.length && closingMatches[closingIndex].start < opening.end) {
        closingIndex++;
      }
      if (closingIndex < closingMatches.length) {
        pairs.push({
          openingEnd: opening.end,
          closingStart: closingMatches[closingIndex].start
        });
        closingIndex++;
      }
    }
    
    if (pairs.length > 0) {
      const pair = pairs[0];
      return content.substring(pair.openingEnd, pair.closingStart);
    }
    return null;
  }

  /**
   * Обработка шаблона имени файла ([[имя]] → текст между маркерами)
   */
  processFilenameTemplate(filename) {
    const tagRegex = /\[\[([^\[\]]+)\]\]/g;
    let processedFilename = filename;
    let match;
    
    while ((match = tagRegex.exec(filename)) !== null) {
      const fullTag = match[0];
      const tagName = match[1];
      const extractedText = this.extractTextBetweenMarkers(tagName);
      
      if (extractedText !== null) {
        processedFilename = processedFilename.replace(fullTag, extractedText);
        tagRegex.lastIndex = 0;
        filename = processedFilename;
      } else {
        tagRegex.lastIndex = 0;
      }
    }
    
    return processedFilename;
  }

  /**
   * Удаление всех маркеров из текста (Ctrl+0)
   */
  removeAllMarkers() {
    this.saveHistoryState();
    const content = this.editor.value;
    const markerRegex = /\[[^<>\[\]\s]+>|<[^<>\[\]\s]+\]/g;
    const newContent = content.replace(markerRegex, '');
    this.editor.value = newContent;
  }

  /**
   * Переключение раскладки выделенного текста (Pause)
   */
  toggleCyrillicSelection() {
    const start = this.editor.selectionStart;
    const end = this.editor.selectionEnd;
    if (start === end) return;
    
    this.saveHistoryState();
    const selectedText = this.editor.value.substring(start, end);
    const toggledText = this.swapLayout(selectedText);
    const before = this.editor.value.substring(0, start);
    const after = this.editor.value.substring(end);
    this.editor.value = before + toggledText + after;
    this.editor.setSelectionRange(start, start + toggledText.length);
  }

  /**
   * Преобразование текста между раскладками (EN ↔ RU)
   */
  swapLayout(text) {
    const enToRu = {
      'q': 'й', 'w': 'ц', 'e': 'у', 'r': 'к', 't': 'е', 'y': 'н', 'u': 'г', 'i': 'ш', 'o': 'щ', 'p': 'з', '[': 'х', ']': 'ъ',
      'a': 'ф', 's': 'ы', 'd': 'в', 'f': 'а', 'g': 'п', 'h': 'р', 'j': 'о', 'k': 'л', 'l': 'д', ';': 'ж', "'": 'э',
      'z': 'я', 'x': 'ч', 'c': 'с', 'v': 'м', 'b': 'и', 'n': 'т', 'm': 'ь', ',': 'б', '.': 'ю', '/': '.',
      'Q': 'Й', 'W': 'Ц', 'E': 'У', 'R': 'К', 'T': 'Е', 'Y': 'Н', 'U': 'Г', 'I': 'Ш', 'O': 'Щ', 'P': 'З', '{': 'Х', '}': 'Ъ',
      'A': 'Ф', 'S': 'Ы', 'D': 'В', 'F': 'А', 'G': 'П', 'H': 'Р', 'J': 'О', 'K': 'Л', 'L': 'Д', ':': 'Ж', '"': 'Э',
      'Z': 'Я', 'X': 'Ч', 'C': 'С', 'V': 'М', 'B': 'И', 'N': 'Т', 'M': 'Ь', '<': 'Б', '>': 'Ю', '?': ','
    };
    
    const ruToEn = {};
    for (const [en, ru] of Object.entries(enToRu)) {
      ruToEn[ru] = en;
    }
    
    let result = '';
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      if (enToRu[char] !== undefined) {
        result += enToRu[char];
      } else if (ruToEn[char] !== undefined) {
        result += ruToEn[char];
      } else {
        result += char;
      }
    }
    return result;
  }

  /**
   * Экранирование спецсимволов для регулярных выражений
   */
  escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }
}

/**
 * Менеджер словарей автозамены
 */
class DictionaryManager {
  constructor() {
    this.dictionaries = this.loadDictionaries();
    this.activeDictionaries = this.loadActiveDictionaries();
    this.combinedActiveDictionary = {};
    this.conflictingShortcuts = new Set();
    this.conflictDetails = {};
    this.selectedShortcut = null;
    this.selectedDictionaryName = null;
    
    this.setupEventListeners();
    this.rebuildActiveDictionary();
    this.checkConflicts();
    this.renderShortcutsTable();
    this.renderDictionariesList();
    this.updateConflictStatus();
    this.setupDropZone();
    this.clearEditFields();
    this.updateCurrentDictNameDisplay();
  }

  /**
   * Загрузка словарей из localStorage
   */
  loadDictionaries() {
    const saved = localStorage.getItem('textEditorDictionaries');
    if (saved) {
      try {
        return JSON.parse(saved);
      } catch (e) {
        console.error('Ошибка при загрузке словарей:', e);
      }
    }
    const initialDict = this.loadInitialDictionary();
    return { 'default': initialDict };
  }

  /**
   * Загрузка начального словаря (включая демонстрационные примеры)
   */
  loadInitialDictionary() {
    const saved = localStorage.getItem('textEditorDictionary');
    if (saved) {
      try {
        return JSON.parse(saved);
      } catch (e) {
        console.error('Ошибка при загрузке старого словаря:', e);
      }
    }
    
    return {
      "тест\\": "\t\tТестовый текст\n[курсор]\nБольшой текст с обязательными числовыми параметрами: первый *, второй *, третий *. Последовательное перемещение по ним нажатием (Alt+X).\n[т>\nРаздел первый: [1>Ещё один абзац, который можно выделить целиком (Alt+Ctrl+1) или дополнить, нажав (Ctrl+1)<1].\nРаздел второй: [2>То же самое, только (Alt+Ctrl+2) и (Ctrl+2)<2].\n<т]\nВыше был пример именованного маркера. Жать (Alt+Ctrl+*) и ввести имя \"т\". Просто выделит текст.\nЧтобы вставить пример сокращения, наберите пс\\, поставив курсор сюда:*\nДля очистки от всех маркеров (Ctrl+0).\nНесколько советов:\nИспользуйте клавиатурные сочетания для работы с текстом - Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X\nТакже удобно пользоваться сочетаниями клавиш для перемещения курсора и выделения - Ctrl+стрелка, Shift+стрелка, Ctrl+Shift+стрелка.\nНазывайте сокращения по первым буквам слов, а в конце или начале используйте редко употребляемый в тексте символ-суффикс для исключения случайных срабатываний (\\, ъ, + и т.д.). В разных словарях используйте разные суффиксы, это уменьшит вероятность конфликтов сокращений.\nЭкспортируйте словарь после внесения в него правок, чтобы сохранить изменения. Некоторые браузеры очищают хранилище при перезапуске.",
      "пс\\": "\n\t=========== Таблица ===============\n\t\tстолбец\t\tстолбец\n\tпервы\t[курсор]\t\t*\n\tвторой\t*\t\t*\n\tтретий\t*\t\t*\n(Нажимайте Alt+X для быстрых переходов по звёздочкам)\n",
      "hello": "[курсор]привет",
      "дд\\": "[курсор]" + new Date().toLocaleDateString(),
      "вв\\": "[курсор]" + new Date().toLocaleTimeString(),
      "tab": "[курсор]\t"
    };
  }

  /**
   * Загрузка списка активных словарей
   */
  loadActiveDictionaries() {
    const saved = localStorage.getItem('textEditorActiveDictionaries');
    if (saved) {
      try {
        const parsed = JSON.parse(saved);
        const activeSet = new Set();
        for (let [key, value] of Object.entries(parsed)) {
          if (value) activeSet.add(key);
        }
        return activeSet;
      } catch (e) {
        console.error('Ошибка при загрузке активных словарей:', e);
      }
    }
    
    const active = new Set();
    if (this.dictionaries && this.dictionaries['default']) {
      active.add('default');
    }
    return active;
  }

  /**
   * Сохранение словарей в localStorage
   */
  saveDictionaries() {
    localStorage.setItem('textEditorDictionaries', JSON.stringify(this.dictionaries));
  }

  /**
   * Сохранение списка активных словарей
   */
  saveActiveDictionaries() {
    const activeObj = {};
    for (let name in this.dictionaries) {
      activeObj[name] = this.activeDictionaries.has(name);
    }
    localStorage.setItem('textEditorActiveDictionaries', JSON.stringify(activeObj));
  }

  /**
   * Получение объединённого активного словаря (без конфликтов)
   */
  getActiveDictionary() {
    return this.combinedActiveDictionary;
  }

  /**
   * Загрузка словаря из файла
   */
  loadDictionaryFromFile(file, fileName) {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const newDict = JSON.parse(e.target.result);
        if (typeof newDict === 'object' && newDict !== null) {
          this.dictionaries[fileName] = newDict;
          if (Object.keys(this.dictionaries).length === 1) {
            this.activeDictionaries.add(fileName);
          }
          this.saveDictionaries();
          this.saveActiveDictionaries();
          this.rebuildActiveDictionary();
          this.checkConflicts();
          this.renderShortcutsTable();
          this.renderDictionariesList();
          this.updateConflictStatus();
          this.updateCurrentDictNameDisplay();
          this.clearEditFields();
        } else {
          alert('Ошибка: файл не содержит корректный JSON-объект словаря.');
        }
      } catch (error) {
        alert('Ошибка при чтении файла: ' + error.message);
      }
    };
    reader.readAsText(file);
  }

  /**
   * Удаление словаря
   */
  removeDictionary(dictName) {
    if (confirm(`Удалить словарь "${dictName}"?`)) {
      delete this.dictionaries[dictName];
      this.activeDictionaries.delete(dictName);
      if (this.selectedDictionaryName === dictName) {
        this.selectedDictionaryName = null;
      }
      this.saveDictionaries();
      this.saveActiveDictionaries();
      this.rebuildActiveDictionary();
      this.checkConflicts();
      this.renderShortcutsTable();
      this.renderDictionariesList();
      this.updateConflictStatus();
      this.updateCurrentDictNameDisplay();
      this.clearEditFields();
    }
  }

  /**
   * Переключение активности словаря
   */
  toggleDictionary(dictName) {
    if (this.activeDictionaries.has(dictName)) {
      this.activeDictionaries.delete(dictName);
    } else {
      this.activeDictionaries.add(dictName);
    }
    this.saveActiveDictionaries();
    this.rebuildActiveDictionary();
    this.checkConflicts();
    this.renderShortcutsTable();
    this.renderDictionariesList();
    this.updateConflictStatus();
    this.clearEditFields();
  }

  /**
   * Экспорт словаря в файл
   */
  exportDictionary(dictName) {
    if (this.dictionaries[dictName]) {
      const json = JSON.stringify(this.dictionaries[dictName], null, 2);
      const blob = new Blob([json], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = dictName + '.txt';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
  }

  /**
   * Пересборка объединённого активного словаря с исключением конфликтов
   */
  rebuildActiveDictionary() {
    this.combinedActiveDictionary = {};
    for (let name of this.activeDictionaries) {
      const dict = this.dictionaries[name];
      if (dict) {
        Object.assign(this.combinedActiveDictionary, dict);
      }
    }
    // Исключение конфликтующих сокращений
    for (let conflict of this.conflictingShortcuts) {
      delete this.combinedActiveDictionary[conflict];
    }
  }

  /**
   * Проверка конфликтов сокращений между активными словарями
   */
  checkConflicts() {
    this.conflictingShortcuts.clear();
    this.conflictDetails = {};
    const shortcutSources = {};
    
    for (let name of this.activeDictionaries) {
      const dict = this.dictionaries[name];
      if (dict) {
        for (let shortcut in dict) {
          if (!shortcutSources[shortcut]) {
            shortcutSources[shortcut] = [];
          }
          shortcutSources[shortcut].push(name);
        }
      }
    }
    
    for (let shortcut in shortcutSources) {
      if (shortcutSources[shortcut].length > 1) {
        this.conflictingShortcuts.add(shortcut);
        this.conflictDetails[shortcut] = shortcutSources[shortcut];
      }
    }
  }

  /**
   * Обновление индикатора статуса конфликтов
   */
  updateConflictStatus() {
    const statusElement = document.getElementById('conflict-status');
    if (this.conflictingShortcuts.size > 0) {
      const conflictMessages = [];
      for (let shortcut in this.conflictDetails) {
        const sources = this.conflictDetails[shortcut];
        if (sources.length > 1) {
          conflictMessages.push(`Конфликт: '${shortcut}' в '${sources[0]}' и '${sources[1]}'`);
          if (sources.length > 2) {
            conflictMessages[conflictMessages.length - 1] += ` и ещё ${sources.length - 2}`;
          }
        }
      }
      statusElement.textContent = conflictMessages.join('; ');
      statusElement.style.display = 'block';
    } else {
      statusElement.style.display = 'none';
    }
  }

  /**
   * Отображение списка словарей
   */
  renderDictionariesList() {
    const tbody = document.getElementById('dictionaries-table-body');
    tbody.innerHTML = '';
    
    for (let name in this.dictionaries) {
      const row = document.createElement('tr');
      row.dataset.dictName = name;
      if (this.selectedDictionaryName === name) {
        row.classList.add('selected');
      }
      
      const toggleCell = document.createElement('td');
      const nameCell = document.createElement('td');
      const actionsCell = document.createElement('td');
      
      const toggleCheckbox = document.createElement('input');
      toggleCheckbox.type = 'checkbox';
      toggleCheckbox.checked = this.activeDictionaries.has(name);
      toggleCheckbox.dataset.dictName = name;
      toggleCheckbox.addEventListener('change', (e) => {
        this.toggleDictionary(e.target.dataset.dictName);
      });
      
      toggleCell.appendChild(toggleCheckbox);
      nameCell.textContent = name;
      actionsCell.innerHTML = `
        <button class="export-dict-btn" data-dict-name="${name}">Экспорт</button>
        <button class="delete-dict-btn" data-dict-name="${name}">Удалить</button>
      `;
      
      row.appendChild(toggleCell);
      row.appendChild(nameCell);
      row.appendChild(actionsCell);
      tbody.appendChild(row);
    }
  }

  /**
   * Отображение таблицы сокращений
   */
  renderShortcutsTable() {
    const tbody = document.getElementById('shortcuts-table-body');
    tbody.innerHTML = '';
    
    let dictToRender = this.combinedActiveDictionary;
    if (this.selectedDictionaryName && this.dictionaries[this.selectedDictionaryName]) {
      dictToRender = this.dictionaries[this.selectedDictionaryName];
    }
    
    for (let shortcut in dictToRender) {
      const row = document.createElement('tr');
      row.dataset.shortcut = shortcut;
      if (this.selectedShortcut === shortcut) {
        row.classList.add('selected');
      }
      if (this.selectedDictionaryName &&
          this.activeDictionaries.has(this.selectedDictionaryName) &&
          this.conflictingShortcuts.has(shortcut)) {
        row.classList.add('conflicting-shortcut-row');
      }
      
      const shortcutCell = document.createElement('td');
      shortcutCell.textContent = shortcut;
      
      const replacementCell = document.createElement('td');
      const preview = dictToRender[shortcut].substring(0, 50);
      replacementCell.textContent = preview + (dictToRender[shortcut].length > 50 ? '...' : '');
      
      row.appendChild(shortcutCell);
      row.appendChild(replacementCell);
      tbody.appendChild(row);
    }
  }

  /**
   * Добавление или обновление сокращения
   */
  addOrUpdateShortcut(shortcut, replacement) {
    if (!shortcut || !shortcut.trim()) {
      DOMUtils.showError(document.getElementById('shortcut-error'), 'Сокращение не может быть пустым');
      return false;
    }
    
    shortcut = shortcut.trim();
    replacement = replacement || '';
    
    // Поиск существующего сокращения во всех словарях
    let foundInDict = null;
    for (let name in this.dictionaries) {
      if (this.dictionaries[name][shortcut] !== undefined) {
        foundInDict = name;
        break;
      }
    }
    
    if (foundInDict) {
      const userConfirmed = confirm(`Сокращение "${shortcut}" существует. Заменить?`);
      if (!userConfirmed) {
        DOMUtils.clearError(document.getElementById('shortcut-error'));
        return false;
      }
      this.dictionaries[foundInDict][shortcut] = replacement;
    } else {
      const targetDictName = this.selectedDictionaryName || 
                             this.activeDictionaries.values().next().value || 
                             'default';
      if (!this.dictionaries[targetDictName]) {
        this.dictionaries[targetDictName] = {};
      }
      this.dictionaries[targetDictName][shortcut] = replacement;
    }
    
    this.saveDictionaries();
    this.rebuildActiveDictionary();
    this.checkConflicts();
    this.renderShortcutsTable();
    this.selectShortcut(shortcut);
    this.renderDictionariesList();
    this.updateConflictStatus();
    DOMUtils.clearError(document.getElementById('shortcut-error'));
    return true;
  }

  /**
   * Удаление сокращения
   */
  deleteShortcut(shortcut) {
    if (shortcut) {
      let foundInDict = null;
      for (let name in this.dictionaries) {
        if (this.dictionaries[name][shortcut] !== undefined) {
          foundInDict = name;
          break;
        }
      }
      
      if (foundInDict) {
        if (confirm(`Удалить сокращение "${shortcut}" из словаря "${foundInDict}"?`)) {
          delete this.dictionaries[foundInDict][shortcut];
          this.saveDictionaries();
          this.rebuildActiveDictionary();
          this.checkConflicts();
          this.renderShortcutsTable();
          this.selectedShortcut = null;
          this.clearEditFields();
          this.renderDictionariesList();
          this.updateConflictStatus();
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Настройка обработчиков событий интерфейса
   */
  setupEventListeners() {
    // Переключение вкладок
    document.querySelectorAll('.tab-button').forEach(button => {
      button.addEventListener('click', (e) => {
        const tabId = e.target.getAttribute('data-tab');
        this.switchTab(tabId);
      });
    });
    
    // Выбор сокращения из таблицы
    document.getElementById('shortcuts-table-body').addEventListener('click', (e) => {
      const row = e.target.closest('tr');
      if (row && row.dataset.shortcut) {
        this.selectShortcut(row.dataset.shortcut);
      }
    });
    
    // Выбор словаря из списка
    document.getElementById('dictionaries-table-body').addEventListener('click', (e) => {
      const row = e.target.closest('tr');
      if (row && row.dataset.dictName) {
        this.selectedShortcut = null;
        document.querySelectorAll('#dictionaries-table-body tr').forEach(r => r.classList.remove('selected'));
        row.classList.add('selected');
        this.selectedDictionaryName = row.dataset.dictName;
        this.clearEditFields();
        this.renderShortcutsTable();
        this.updateCurrentDictNameDisplay();
      }
    });
    
    // Кнопки сохранения и удаления сокращения
    document.getElementById('save-shortcut-btn').addEventListener('click', () => {
      const shortcut = document.getElementById('edit-shortcut').value;
      const replacement = document.getElementById('edit-replacement').value;
      this.addOrUpdateShortcut(shortcut, replacement);
    });
    
    document.getElementById('delete-shortcut-btn').addEventListener('click', () => {
      const shortcut = document.getElementById('edit-shortcut').value;
      if (shortcut) {
        this.deleteShortcut(shortcut);
      }
    });
    
    // Экспорт и удаление словарей
    document.getElementById('dictionaries-table-body').addEventListener('click', (e) => {
      if (e.target.classList.contains('export-dict-btn')) {
        const dictName = e.target.dataset.dictName;
        this.exportDictionary(dictName);
      }
      if (e.target.classList.contains('delete-dict-btn')) {
        const dictName = e.target.dataset.dictName;
        this.removeDictionary(dictName);
      }
    });
  }

  /**
   * Настройка зоны перетаскивания для импорта словарей
   */
  setupDropZone() {
    const dropZone = document.getElementById('drop-zone');
    
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      dropZone.addEventListener(eventName, (e) => {
        e.preventDefault();
        e.stopPropagation();
      }, false);
    });
    
    ['dragenter', 'dragover'].forEach(eventName => {
      dropZone.addEventListener(eventName, () => {
        dropZone.classList.add('dragover');
      }, false);
    });
    
    ['dragleave', 'drop'].forEach(eventName => {
      dropZone.addEventListener(eventName, () => {
        dropZone.classList.remove('dragover');
      }, false);
    });
    
    dropZone.addEventListener('drop', (e) => {
      const files = e.dataTransfer.files;
      if (files.length) {
        const file = files[0];
        let fileName = file.name;
        if (fileName.endsWith('.txt')) {
          fileName = fileName.substring(0, fileName.length - 4);
        }
        if (this.dictionaries[fileName]) {
          if (!confirm(`Словарь "${fileName}" уже существует. Загрузить и заменить?`)) {
            return;
          }
        }
        this.loadDictionaryFromFile(file, fileName);
      }
    });
  }

  /**
   * Переключение активной вкладки
   */
  switchTab(tabId) {
    document.querySelectorAll('[id$="-tab"]').forEach(tab => {
      tab.classList.remove('active');
    });
    document.getElementById(tabId).classList.add('active');
    
    document.querySelectorAll('.tab-button').forEach(button => {
      button.classList.remove('active');
    });
    document.querySelector(`[data-tab="${tabId}"]`).classList.add('active');
  }

  /**
   * Выбор сокращения для редактирования
   */
  selectShortcut(shortcut) {
    this.selectedShortcut = shortcut;
    document.querySelectorAll('#shortcuts-table-body tr').forEach(row => row.classList.remove('selected'));
    const row = document.querySelector(`#shortcuts-table-body tr[data-shortcut="${shortcut}"]`);
    if (row) row.classList.add('selected');
    
    document.getElementById('edit-shortcut').value = shortcut;
    let dictToUse = this.combinedActiveDictionary;
    if (this.selectedDictionaryName && this.dictionaries[this.selectedDictionaryName]) {
      dictToUse = this.dictionaries[this.selectedDictionaryName];
    }
    document.getElementById('edit-replacement').value = dictToUse[shortcut] || '';
    this.updateButtonsState();
    DOMUtils.clearError(document.getElementById('shortcut-error'));
  }

  /**
   * Очистка полей редактирования
   */
  clearEditFields() {
    document.getElementById('edit-shortcut').value = '';
    document.getElementById('edit-replacement').value = '';
    this.updateButtonsState();
    DOMUtils.clearError(document.getElementById('shortcut-error'));
  }

  /**
   * Обновление состояния кнопок (активность кнопки удаления)
   */
  updateButtonsState() {
    const deleteBtn = document.getElementById('delete-shortcut-btn');
    const shortcut = document.getElementById('edit-shortcut').value;
    let exists = false;
    
    for (let name in this.dictionaries) {
      if (this.dictionaries[name][shortcut] !== undefined) {
        exists = true;
        break;
      }
    }
    
    deleteBtn.disabled = !exists;
  }

  /**
   * Обновление отображения имени редактируемого словаря
   */
  updateCurrentDictNameDisplay() {
    const titleElement = document.getElementById('editing-dict-title');
    if (this.selectedDictionaryName) {
      titleElement.textContent = `Редактирование словаря "${this.selectedDictionaryName}"`;
    } else {
      titleElement.textContent = 'Редактирование словаря';
    }
  }
}

/**
 * Инициализация приложения после загрузки DOM
 */
document.addEventListener('DOMContentLoaded', () => {
  // Анимация заголовка при клике
  const titleElement = document.getElementById('animated-title');
  const sequence = ['|','n|', 'nw|', 'NW', 'NoWa', 'NotWar', 'NoteWarp'];
  let isAnimating = false;
  
  titleElement.addEventListener('click', () => {
    if (isAnimating) return;
    isAnimating = true;
    let index = 0;
    const interval = setInterval(() => {
      if (index < sequence.length) {
        titleElement.textContent = sequence[index];
        if (index === 3) {
          clearInterval(interval);
          const newInterval = setInterval(() => {
            index++;
            if (index < sequence.length) {
              titleElement.textContent = sequence[index];
            } else {
              clearInterval(newInterval);
              isAnimating = false;
            }
          }, 50);
        }
        index++;
      } else {
        clearInterval(interval);
        isAnimating = false;
      }
    }, 200);
  });
  
  // Создание основных компонентов приложения
  const dictionaryManager = new DictionaryManager();
  const feedbackManager = new FeedbackManager();
  const editorElement = document.getElementById('editor');
  const editor = new TextEditor(editorElement, dictionaryManager, feedbackManager);
  
  // Настройка кнопки справки
  const helpButton = document.getElementById('help-button');
  const currentTabId = () => {
    if (document.getElementById('editor-tab').classList.contains('active')) return 'editor';
    if (document.getElementById('dictionary-tab').classList.contains('active')) return 'dictionary';
    return null;
  };
  
  const showHelp = () => {
    const tab = currentTabId();
    let helpContent = '';
    
    if (tab === 'editor') {
      helpContent = `
        <h3>Справка: Редактор</h3>
        <p>Основное окно для редактирования текста.</p>
        <ul>
          <li><strong>Автозамена:</strong> Сокращения из активных словарей автоматически заменяются на соответствующий текст.</li>
          <li><strong>Поиск *:</strong> Alt+X — поиск следующего символа *.</li>
          <li><strong>Маркеры:</strong> Для навигации используйте <code>[цифра></code> и <code><цифра]</code> или <code>[имя></code> и <code><имя]</code>.</li>
          <li><strong>Навигация по маркерам:</strong>
            <ul>
              <li>Ctrl+цифра или Ctrl+* — переход к закрывающему маркеру.</li>
              <li>Ctrl+Alt+цифра или Ctrl+Alt+* — выделение между маркерами.</li>
            </ul>
          </li>
          <li><strong>Смена раскладки:</strong> Pause — изменение раскладки для выделенного текста.</li>
          <li><strong>Отмена/Повтор:</strong>
            <ul>
              <li>Ctrl+Z (или Ctrl+Я) — отмена.</li>
              <li>Ctrl+Y (или Ctrl+Н) — повтор.</li>
            </ul>
          </li>
          <li><strong>Табуляция:</strong> Tab — вставка отступа в текстовом поле.</li>
          <li><strong>Имя файла по шаблону:</strong> Тег <code>[[имя]]</code> подставляет текст между маркерами <code>[имя></code> и <code><имя]</code>.</li>
          <li><strong>Удаление маркеров:</strong> Ctrl+0 — удаление всех маркеров из текста.</li>
          <li><strong>Сохранение:</strong> Введите имя файла и нажмите «Сохранить» или Enter.</li>
          <li><strong>Уведомления:</strong> Включите в панели под редактором (звуковые/визуальные).</li>
        </ul>
      `;
    } else if (tab === 'dictionary') {
      helpContent = `
        <h3>Справка: Словарь</h3>
        <p>Управление словарями автозамены.</p>
        <ul>
          <li><strong>Управление словарями:</strong> В левой верхней части — загрузка, экспорт, удаление. Чекбоксы включают/отключают словари.</li>
          <li><strong>Конфликты:</strong> Сокращения, присутствующие в нескольких активных словарях, исключаются из автозамены. Статус конфликта — под таблицей.</li>
          <li><strong>Добавление словаря:</strong> Создайте текстовый файл с именем словаря и содержимым <strong>{}</strong>, затем перетащите в зону импорта.</li>
          <li><strong>Редактирование словаря:</strong> Выберите словарь из списка для правки сокращений.</li>
          <li><strong>Таблица сокращений:</strong> Отображает сокращения и подстановки. Конфликтующие — выделены красным.</li>
          <li><strong>Редактирование подстановки:</strong> Выберите сокращение в таблице, измените в правой панели, нажмите «Сохранить».</li>
          <li><strong>Добавление сокращения:</strong> Введите сокращение и подстановку в правой панели, нажмите «Сохранить».</li>
          <li><strong>Удаление сокращения:</strong> Выберите сокращение, нажмите «Удалить».</li>
        </ul>
      `;
    } else {
      helpContent = '<p>Неизвестная вкладка.</p>';
    }
    
    DOMUtils.createHelpPopup(helpContent, () => {
      editorElement.focus();
    });
  };
  
  helpButton.addEventListener('click', showHelp);
  editorElement.focus();
});
</script>
</body>
</html>